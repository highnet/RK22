using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using static GarageManager;
using static RaceController;
using DG.Tweening;

public class FinishLine : MonoBehaviour
{
    public enum Track { Track0, Track1 } // the types of possible tracks

    public Track track; // the type of track in which the finish line resides on
    public RaceController raceController; // the race controller
    public KartController kartController; // the kart controller
    public AudioClipPlayer audioClipPlayer; // the finish line's audio clip player
    public RacingUIController racingUIController; // the racing ui controller
    public RecordEntry recordEntry; // the record entry to be generated by race in which the finish line resides on
    public List<RecordEntry> recordEntries; // the list of record entries for this track type in which the recordEntry will compete against
    public CameraManager cameraManager; // the camera manager
    public OutOfBounds outOfBounds;
    public GhostRacerSaver ghostRacerSaver;
    private void Start()
    {
        kartController = FindObjectOfType<KartController>(); // store a local reference to the kart controller
        cameraManager = FindObjectOfType<CameraManager>(); // store a local reference to the camera manager
        racingUIController = FindObjectOfType<RacingUIController>(); // store a local reference to the racing ui controller
        outOfBounds = FindObjectOfType<OutOfBounds>();
        ghostRacerSaver = FindObjectOfType<GhostRacerSaver>();
    }
    private void OnTriggerEnter(Collider other)
    {
        if (other.tag == "Player") // check the collision object for the "Player" tag
        {
            bool metAllLapRequirements = true; // flag for checking if we met all requirements to fully complete a lap. initially assume we met all requirements to complete the lap and prove then we try to prove it wrong

            metAllLapRequirements = raceController.requiredCheckpoints[0].active && raceController.requiredCheckpoints[1].active && raceController.requiredCheckpoints[2].active; // every map has 3 checkpoints the player must trigger for completion, therefore here we check that all three checkpoints are active

            if (metAllLapRequirements) // if we met all lap requirements
            {
                kartController.characterClipPlayer.PlayOneShot(0, 4, 1.0f, true); // play the character lap completed sound
                raceController.lapNumber++; // increment the race controller's lap number
                raceController.lapTimes.Add(raceController.currentLapTimer); // add the race controller's current lap timer to the race controller's list of lap times
                racingUIController.lapCounterText.text = (raceController.lapNumber - 1) + "/" + (raceController.totalNumberOfLaps - 1); // update the racin ui controller's lap number text with the correct lap number


                foreach (RespawnPoint respawnPoint in outOfBounds.respawnPoints)
                {
                    respawnPoint.active = false;
                }

                foreach (Checkpoint checkPoint in raceController.requiredCheckpoints) // for each checkpoint
                {
                    checkPoint.active = false; // reset all checkpoints back to inactive
                }

                if (raceController.lapNumber == raceController.totalNumberOfLaps) // if the current lap number is equal to the total number of laps (race is over condition)
                {
                    audioClipPlayer.PlayOneShot(0, 1, 1.0f, true); // play the finish line's race is over fanfare sound
                    kartController.controllable = false; // make the kart controller uncontrollable
                    raceController.racePhase = RacePhase.TimeTrialGameEnd; // set the race phase to time trial game end
                    recordEntry = new RecordEntry(raceController.totalLapTimer, "You" , (Character) PlayerPrefs.GetInt("ChosenCharacterIndex"), (KartBody) PlayerPrefs.GetInt("ChosenKartBodyIndex")); // generate the new record entry
                    Records records = SaveSystem.LoadRecords(); // load the player's records from the save system
                    records.registry.TryGetValue(track.ToString(), out recordEntries); // get the track's record entries from the player's records
                    recordEntries.Add(recordEntry); // add the new record entry to the record entries
                    recordEntries = SaveSystem.SortRecordEntries(recordEntries); // sort the record entries, so that the new entry goes into the right position
                    racingUIController.UpdateRecordTimerTexts(recordEntries); // update the racing ui's record timer texts to reflect the track's new records
                    records.registry[track.ToString()] = recordEntries; //  put the new record entries back into the record's registry
                    SaveSystem.SaveRecords(records); // save the newly updated records
                    racingUIController.endOfRacePanel.transform.DOMove(racingUIController.transform.position, 2.0f); // tween the end of race panel's position into the player's screen view
                    racingUIController.endOfRacePanel.GetComponent<EndOfRacePanel>().PrepareEndOfRaceScreen(); // prepare the end of race panel screen
                    cameraManager.ActivateEndGameCam(); // activate the end game cinemachine virtual camera
                    ghostRacerSaver.SavePath(track,raceController.totalLapTimer);
                }
                else
                {
                    audioClipPlayer.PlayOneShot(0, 0, 1.0f, true); // play the finish line's lap is over fanfare sound
                    raceController.currentLapTimer = 0f; // reset the race controller's current lap tiper back to 0
                }
            }            
        }
    }
}
